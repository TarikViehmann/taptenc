/** \file
 * Printer to produce uppaal 4.0 xml output format.
 *
 * The xml output format combines syntactical and graphical information.
 *
 * \author (2019) Tarik Viehmann
 */

#include "../constraints/constraints.h"
#include "../timed-automata/timed_automata.h"
#include "printer.h"
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

using namespace taptenc;

namespace taptenc {
/**
 * Private helper functions for the XMLPrinter class.
 */
namespace xmlprinterutils {

/**
 *  xml header with version and encoding info.
 *
 *  Adapted from uppaal autogenerated files. Opens nta tag that needs to be
 *  closed.
 */
constexpr char XML_HEADER[]{
    "<?xml version=\"1.0\" encoding=\"utf-8\"?><!DOCTYPE nta PUBLIC "
    "\'-//Uppaal Team//DTD Flat System 1.1//EN\' "
    "\'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd\'><nta>"};

/**
 * Creates an xml formatted string (according to uppaal 4.0 syntax) that
 * holds information of a state.
 *
 * @param s state to xml format
 * @param pos x and y position of \a s
 * @return xml formatted string of \a s accoding to uppaal 4.0 xml format
 */
std::string toString(const State &s, const std::pair<int, int> &pos) {
  std::stringstream res;
  res << "<location id=\"" << s.id << "\" x=\"" << pos.first << "\" y=\""
      << pos.second << "\">";
  if (s.id != "") {
    res << "<name x=\"" << pos.first << "\" y=\"" << pos.second - 20 << "\">"
        << s.id << "</name>";
  }
  if (s.inv.get()->type != CCType::TRUE) {
    res << "<label kind=\"invariant\" x=\"" << pos.first << "\" y=\""
        << pos.second + 10 << "\">" << s.inv.get()->toString() << "</label>";
  }
  if (s.urgent) {
    res << "<urgent/>" << std::endl;
  }
  res << "</location>";
  return res.str();
}

/*
 * Creates an xml formatted string (according to uppaal 4.0 syntax) that holds
 * information of a transition.
 *
 * @param t transition to xml format
 * @param v vector of nails, needs to contain at least one position in order to
 *          encode the label positions
 * @return xml formatted string of \a s accoding to uppaal 4.0 xml format
 * OR empty string, if \a v is empty
 */
std::string toString(const Transition &t,
                     const std::vector<std::pair<int, int>> &v) {
  std::stringstream res;
  if (v.size() == 0) {
    std::cout
        << "XMLPrinter toString(Transition): unexpected empty std::vector, "
           "mid_point missing!"
        << std::endl;
    return "";
  }
  res << "<transition>";
  res << "<source ref=\"" << t.source_id << "\"/>";
  res << "<target ref=\"" << t.dest_id << "\"/>";
  if (t.sync != "" && t.passive)
    res << "<label kind=\"synchronisation\" x=\"" << v[0].first << "\" y=\""
        << v[0].second + 10 << "\">" << t.sync << "?"
        << "</label>" << std::endl;
  if (t.sync != "" && t.passive == false)
    res << "<label kind=\"synchronisation\" x=\"" << v[0].first << "\" y=\""
        << v[0].second + 10 << "\">" << t.sync << "!"
        << "</label>" << std::endl;
  if (t.guard.get()->type != CCType::TRUE)
    res << "<label kind=\"guard\" x=\"" << v[0].first << "\" y=\""
        << v[0].second - 20 << "\">" << t.guard.get()->toString() << "</label>"
        << std::endl;
  if (t.update.size() > 0)
    res << "<label kind=\"assignment\" x=\"" << v[0].first << "\" y=\""
        << v[0].second - 40 << "\">" << t.updateToString() << "</label>"
        << std::endl;
  if (v.size() > 0) {
    for (auto it = v.begin() + 1; it != v.end(); ++it) {
      res << "<nail x=\"" << it->first << "\" y=\"" << it->second << "\"/>"
          << std::endl;
    }
  }
  res << "</transition>" << std::endl;
  return res.str();
}

/**
 * Appends the global definitions formatted according to uppaal 4.0 xml syntax
 * to a file.
 *
 * Also  opens the nta tag which has to be closed later by printXMLend()
 *
 * @param g global automata system variables
 * @param filename name of file to append the formatted info
 */
void printXMLstart(const AutomataGlobals &g, std::string filename) {
  std::ofstream myfile;
  myfile.open(filename);
  myfile << XML_HEADER;
  myfile << "<declaration>";
  if (g.clocks.size() > 0) {
    myfile << "clock ";
    for (auto it = g.clocks.begin(); it != g.clocks.end(); ++it) {
      if (it != g.clocks.begin()) {
        myfile << ", ";
      }
      myfile << it->get()->id;
    }
    myfile << "; " << std::endl;
  }
  bool empty = true;
  for (auto it = g.channels.begin(); it != g.channels.end(); ++it) {
    if (it->type == ChanType::Broadcast) {
      if (empty == false) {
        myfile << ", ";
      }
      if (empty == true) {
        myfile << "broadcast chan ";
      }
      myfile << it->name;
      empty = false;
    }
  }
  if (empty == false) {
    myfile << "; " << std::endl;
  }
  empty = true;
  for (auto it = g.channels.begin(); it != g.channels.end(); ++it) {
    if (it->type == ChanType::Binary) {
      if (empty == false) {
        myfile << ", ";
      }
      if (empty == true) {
        myfile << "chan ";
      }
      myfile << it->name;
      empty = false;
    }
  }
  if (empty == false) {
    myfile << "; " << std::endl;
  }
  myfile << "</declaration>" << std::endl;
  myfile.close();
}

/**
 * Appends a closing nta tag to a file.
 *
 * Use when all templates are written. Closes the nta tag contained in
 * #XML_HEADER that is written by printXMLstart().
 *
 * @param filename name of file to append the formatted info
 */
void printXMLend(std::string filename) {
  std::ofstream myfile;
  myfile.open(filename, std::ios_base::app);
  myfile << "</nta>" << std::endl;
  myfile.close();
}

/**
 * Appends a xml encoded automaton template to a file.
 *
 * Currently templates are not really supported, because of the modeling of
 * AutomataSystem::instances.
 *
 * @param s Automata System that contains the template in questiom
 * @param s_vis_info visual information associated with \a s
 * @param index template index in AutomataSystem::instances of \a s
 * @param filename name of file to append the formatted template
 */
void printXMLtemplate(const AutomataSystem &s, SystemVisInfo &s_vis_info,
                      int index, std::string filename) {
  std::ofstream myfile;
  myfile.open(filename, std::ios_base::app);
  myfile << "<template>";
  myfile << "<name x=\"0\" y=\"0\">" << s.instances[index].first.prefix
         << "</name>" << std::endl;
  myfile << "<declaration>" << std::endl;
  for (auto toplevelit = s.instances[index].first.clocks.begin();
       toplevelit != s.instances[index].first.clocks.end(); ++toplevelit) {
    myfile << "clock " << toplevelit->get()->id << ";" << std::endl;
  }
  for (auto toplevelit = s.instances[index].first.bool_vars.begin();
       toplevelit != s.instances[index].first.bool_vars.end(); ++toplevelit) {
    myfile << "bool " << *toplevelit << " = false;" << std::endl;
  }
  myfile << "</declaration>" << std::endl;
  bool initial_state_set = false;
  std::string init_id;
  for (auto toplevelit = s.instances[index].first.states.begin();
       toplevelit != s.instances[index].first.states.end(); ++toplevelit) {
    myfile << toString(*toplevelit,
                       s_vis_info.getStatePos(index, toplevelit->id))
           << std::endl;
    if (initial_state_set == false && toplevelit->initial == true) {
      init_id = toplevelit->id;
      initial_state_set = true;
    }
  }
  if (initial_state_set == false) {
    std::cout
        << "XMLPrinter printXMLTemplate: no initial state found (template: "
        << s.instances[index].first.prefix << ")" << std::endl;
    init_id = s.instances[index].first.states.begin()->id;
    initial_state_set = true;
  }
  myfile << "<init ref=\"" << init_id << "\"/>";
  for (auto toplevelit = s.instances[index].first.transitions.begin();
       toplevelit != s.instances[index].first.transitions.end(); ++toplevelit) {
    myfile << toString(*toplevelit,
                       s_vis_info.getTransitionPos(index, toplevelit->source_id,
                                                   toplevelit->dest_id))
           << std::endl;
  }
  myfile << "</template>" << std::endl;
  myfile.close();
}

/**
 * Appends xml encoding of a system declaration to file.
 *
 * Currently a non-empty parameter list of an entry in \a instances requires
 * the associated automaton to already contain the assigned parameter values.
 *
 * @param instances instances consisting of an automaton and a string
 *        containing the parameter list.
 * @param filename name of file to append the formatted system definition
 */
void printXMLsystem(
    const std::vector<std::pair<Automaton, std::string>> &instances,
    std::string filename) {
  std::ofstream myfile;
  myfile.open(filename, std::ios_base::app);
  myfile << "<system>" << std::endl;
  std::string system = "system ";
  for (auto toplevelit = instances.begin(); toplevelit != instances.end();
       ++toplevelit) {
    if (toplevelit != instances.begin()) {
      system += ", ";
    }
    std::string component = "sys_" + toplevelit->first.prefix;
    myfile << component << " = " << toplevelit->first.prefix << "("
           << toplevelit->second << ");" << std::endl;
    system += component;
  }
  myfile << system << ";" << std::endl;
  myfile << "</system>" << std::endl;
  myfile.close();
}
} // end namespace xmlprinterutils
} // end namespace taptenc

void XMLPrinter::print(const AutomataSystem &s, SystemVisInfo &s_vis_info,
                       std::string filename) {
  xmlprinterutils::printXMLstart(s.globals, filename);
  for (auto it = s.instances.begin(); it != s.instances.end(); ++it) {
    xmlprinterutils::printXMLtemplate(s, s_vis_info, it - s.instances.begin(),
                                      filename);
  }
  xmlprinterutils::printXMLsystem(s.instances, filename);
  xmlprinterutils::printXMLend(filename);
}
